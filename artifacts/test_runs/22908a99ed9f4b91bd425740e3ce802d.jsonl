{"run_id": "22908a99ed9f4b91bd425740e3ce802d", "test_id": "test/test_e27_area_get_status_live.py::test_live_area_get_status", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-27T06:35:14Z", "meta": {"pid": 82999}}
{"run_id": "22908a99ed9f4b91bd425740e3ce802d", "test_id": "test/test_e27_area_get_status_live.py::test_live_area_get_status", "record_type": "test_end", "t_ms": 10048, "ts_utc": "2025-12-27T06:35:24Z", "outcome": "fail", "error": {"when": "call", "longrepr": "self = <elke27_lib.elk.Elk object at 0x10b378050>\npanel = {'host': '192.168.1.197', 'port': 2101}\nidentity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if identity is None:\n            raise ElkError(\"link(): identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                try:\n                    tempkey_hex, linkkey_hex, linkhmac_hex = linking.perform_api_link(\n                        sock=sock,\n                        identity=identity,\n                        access_code=access_code,\n                        passphrase=passphrase,\n                        mn_for_hash=identity.mn,\n                        discovery_nonce=nonce,\n                        seq=110,\n                        timeout_s=float(timeout_s),  # may be accepted in updated linking.py\n                    )\n                except TypeError:\n                    # Backward signature (no timeout_s kw)\n                    tempkey_hex, linkkey_hex, linkhmac_hex = linking.perform_api_link(\n                        sock=sock,\n                        identity=identity,\n                        access_code=access_code,\n                        passphrase=passphrase,\n                        mn_for_hash=identity.mn,\n                        discovery_nonce=nonce,\n                        seq=110,\n                    )\n    \n                return E27LinkKeys(\n                    tempkey_hex=str(tempkey_hex),\n                    linkkey_hex=str(linkkey_hex),\n                    linkhmac_hex=str(linkhmac_hex),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n>           link_keys = await asyncio.to_thread(_do_link_sync)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nelke27_lib/elk.py:318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/threads.py:25: in to_thread\n    return await loop.run_in_executor(None, func_call)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:86: in run\n    result = ctx.run(self.task)\n             ^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:73: in run\n    return fn(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def _do_link_sync() -> E27LinkKeys:\n        import socket\n    \n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.settimeout(float(timeout_s))\n>           sock.connect((host, port))\nE           TimeoutError: timed out\n\nelke27_lib/elk.py:277: TimeoutError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_area_get_status() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"10.0\") or 10.0)\n        area_id = int(_env(\"ELKE27_AREA_ID\", \"1\") or 1)\n    \n        identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n    \n        elk = Elk(features=[\"elke27_lib.features.area\"])\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n>       link_keys = await elk.link(panel, identity, creds, timeout_s=timeout_s)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_e27_area_get_status_live.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.elk.Elk object at 0x10b378050>\npanel = {'host': '192.168.1.197', 'port': 2101}\nidentity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if identity is None:\n            raise ElkError(\"link(): identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                try:\n                    tempkey_hex, linkkey_hex, linkhmac_hex = linking.perform_api_link(\n                        sock=sock,\n                        identity=identity,\n                        access_code=access_code,\n                        passphrase=passphrase,\n                        mn_for_hash=identity.mn,\n                        discovery_nonce=nonce,\n                        seq=110,\n                        timeout_s=float(timeout_s),  # may be accepted in updated linking.py\n                    )\n                except TypeError:\n                    # Backward signature (no timeout_s kw)\n                    tempkey_hex, linkkey_hex, linkhmac_hex = linking.perform_api_link(\n                        sock=sock,\n                        identity=identity,\n                        access_code=access_code,\n                        passphrase=passphrase,\n                        mn_for_hash=identity.mn,\n                        discovery_nonce=nonce,\n                        seq=110,\n                    )\n    \n                return E27LinkKeys(\n                    tempkey_hex=str(tempkey_hex),\n                    linkkey_hex=str(linkkey_hex),\n                    linkhmac_hex=str(linkhmac_hex),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n            link_keys = await asyncio.to_thread(_do_link_sync)\n        except Exception as e:\n>           raise ElkError(f\"Linking failed for {host}:{port}: {e}\") from e\nE           elke27_lib.elk.ElkError: Linking failed for 192.168.1.197:2101: timed out\n\nelke27_lib/elk.py:320: ElkError"}}
